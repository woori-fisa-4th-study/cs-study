## 1.3 프로세스와 스레드

[👉🏻 참고자료가 포함된 노션 정리본](https://www.notion.so/yxhwxn/1-3-17320d7de67880de9121c6d02f149bdd)

</br>

### 1. 프로세스(Process)와 스레드(Thread)의 차이점을 설명해주세요.

> 답변

> 프로세스와 스레드는 프로그램이 실행되는 단위라는 공통점이 있지만, 두 개념에는 메모리가 어떻게 할당되고 관리되는지에 따라 차이가 있습니다. 
> 먼저, 프로세스는 운영체제로부터 독립적인 메모리 공간과 자원을 할당받아 실행되는 단위로, 각 프로세스는 고유한 메모리 공간을 사용하기 때문에 다른 프로세스와 메모리를 공유하지 않습니다.
> 이와 달리, 스레드는 프로세스 내부에서 동작하는 실행 단위로, 같은 프로세스 내에서 코드, 데이터, 파일 등 메모리 자원을 공유할 수 있어 IPC 통신과 달리 더 빠르고 효율적인 통신이 가능하다는 차이가 있습니다.

</br>

### 2. 멀티프로세싱(Multiprocessing)과 멀티스레딩(Multithreading)의 차이점은 무엇인가요?

> 답변

> 멀티프로세싱과 멀티스레딩은 병렬 처리를 위한 기술이지만, 자원 관리 방식과 통신 방식에서 차이가 있습니다.
> 멀티프로세싱은 여러 프로세스를 동시에 실행하는 방식으로, 각 프로세스는 독립적인 메모리 공간을 사용하고 운영체제로부터 별도의 자원을 할당받기 때문에 안정적이고 안전한 메모리 보호가 가능합니다. 다만, 프로세스 간 통신(IPC)이 필요하여 오버헤드가 크고 속도가 느릴 수 있습니다.
> 반면, 멀티스레딩은 하나의 프로세스 내에서 여러 스레드를 실행하는 방식으로, 모든 스레드가 같은 메모리 공간을 공유합니다. 이로 인해 스레드 간 통신이 빠르고 효율적이지만, 데이터 충돌이나 동기화 문제가 발생할 수 있어 이를 해결하기 위해 Lock, Semaphore와 같은 동기화 메커니즘이 필요합니다.
> 멀티프로세싱은 안정성과 메모리 보호가 중요할 때 적합하고, 멀티스레딩은 병렬 처리가 필요한 경량 작업에 더 효율적이라고 알고 있습니다.

</br>

### 3. 프로세스 상태(Process State)의 변화를 설명해보세요.

> 답변

> 멀티프로세싱 환경에서 적용되는 프로세스의 상태는 `new`, `ready`, `running`, `waiting`, `terminated` 가 있습니다.
> 사용자가 파일을 읽는 프로그램을 실행한다고 가정해서 Process State 변화에 대해 설명해드리겠습니다. 먼저 사용자가 프로그램을 실행하면 new 상태에서 ready 상태인 프로세스로 전환됩니다. 이후, 해당 프로세스가 스케줄러에 의해 CPU가 할당되면 running 상태가 되고, 프로그램 도중 read() 시스템 콜을 수행하려고 할 때 커널모드로 수행되어야 되어야 하기 때문에 waiting 상태로 전환됩니다. trap handler에 의해 커널 작업을 모두 수행하면 다시 ready 상태로 돌아가게 됩니다. 이후, 프로세스가 모든 작업을 끝내면 terminated 상태로 전환됩니다.

</br>

### 4. 문맥 전환(Context Switching)은 언제 발생하며, 왜 필요한가요?

> 답변

> 저희가 흔히 알고 있는 멀티프로세싱과 멀티스레딩 방식은 사실상 동시에 실행되는 것이 아니라, 운영체제의 Context Switching을 빠르게 반복해서 여러 프로세스를 동시에 실행하는 것처럼 보이는 개념입니다.
> 여기서 문맥 전환(Context Switching) CPU가 현재 실행 중인 프로세스나 스레드의 상태를 저장하고, 새로운 프로세스를 실행하기 위해 이전 상태를 복원하는 과정을 뜻합니다.
> 문맥 전환은 멀티태스킹 환경에서 CPU가 여러 프로세스를 번갈아가며 실행할 때 발생하며, 스케줄링, I/O 요청, 인터럽트 처리 등 다양한 상황에서 발생하는데요, 멀티태스킹 환경에서 운영체제가 효율적으로 프로세스를 동작시키려면 Context Switching은 반드시 필요한 개념이라고 알고 있습니다.

</br>

### 5. **사용자 수준 스레드 vs 커널 수준 스레드 차이는?**

> **사용자 수준 스레드**
> 
> - 장점
>     - context switching이 없어서 커널 스레드보다 오버헤드가 적음 (스레드 전환 시 커널 스케줄러 호출할 필요가 없기 때문)
> - 단점
>     - 프로세스 내의 한 스레드가 커널로 진입하는 순간, 나머지 스레드들도 전부 정지됨 (커널이 스레드의 존재를 알지 못하기 때문에)
> 
> **커널 수준 스레드**
> 
> - 장점
>     - 사용자 수준 스레드보다 효율적임. 커널 스레드를 쓰면 멀티프로세서를 활용할 수 있기 때문이다. 사용자 스레드는 CPU가 아무리 많아도 커널 모드의 스케줄이 되지 않으므로, 각 CPU에 효율적으로 스레드 배당할 수가 없음
> - 단점
>     - context switching이 발생함. 이 과정에서 프로세서 모드가 사용자 모드와 커널 모드 사이를 움직이기 때문에 많이 돌아다닐 수록 성능이 떨어지게 된다.
